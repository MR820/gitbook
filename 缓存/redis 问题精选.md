![](https://oss.wyxxt.org.cn/images/2021/09/18/5ebc1dc19c9baeffcbe9e3559a958155.png)







### redis两大要点

1. 计算向数据移动（省IO）

2. 串行化




![](https://oss.wyxxt.org.cn/images/2021/09/18/wp_editor_md_4addb236939ee99627fbb8e869b6f619.jpg)



### 1. redis是什么？有哪些使用场景
[redis基本数据类型及操作](https://wyxxt.org.cn/archives/redis数据类型及基本操作.html "redis基本数据类型及操作")
首先要说redis,应该先说一下nosql,
NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，
泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。
（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。

Redis:REmote DIctionary Server(远程字典服务器)是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。

#### 使用场景
1、热点数据的缓存
由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。

2、限时业务的运用
redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

3、计数器相关问题
redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

4、排行榜相关问题
关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。

在奶茶活动中，我们需要展示各个部门的点赞排行榜， 所以我针对每个部门做了一个SortedSet,然后以用户的openid作为上面的username,以用户的点赞数作为上面的score, 然后针对每个用户做一个hash,通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。

  5、分布式锁
这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0。需要结合过期时间，防止死锁

6、点赞、好友等相互关系的存储
Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 又或者在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。

这个在奶茶活动中有运用，就是利用set存储用户之间的点赞关联的，另外在点赞前判断是否点赞过就利用了sismember方法，当时这个接口的响应时间控制在10毫秒内，十分高效。

7、队列
由于redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。


### 2. redis有哪些功能
Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。
Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。

### 3. redis和memcache的区别
1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。
2)、数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。
3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

### 4. redis为什么是单线程的
因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。采用队列模式将并发访问变为串行访问。
需要注意的是，单线程指的是**网络请求模块**使用了一个线程（所以不需考虑并发安全性），其他模块仍用了多个线程。

### 5. 缓存穿透是什么？怎么解决
在高并发场景下，如果某一个key被高并发访问，没有被命中，出于对容错性考虑，会尝试去从后端数据库中获取，从而导致了大量请求达到数据库，而当该key对应的数据本身就是空的情况下，这就导致数据库中并发的去执行了很多不必要的查询操作，从而导致巨大冲击和压力。
可以通过下面的几种常用方式来避免缓存传统问题：
1、缓存空对象
对查询结果为空的对象也进行缓存，如果是集合，可以缓存一个空的集合（非null），如果是缓存单个对象，可以通过字段标识来区分。这样避免请求穿透到后端数据库。这种方式实现起来成本较低。
如果后面某个为空的记录在数据库中有数据了，该如何处理？
可以提前设置缓存的时效性，等过期之后自然会到后端刷新新数据。
如果时效性要求很高的话，那就采用数据库与缓存双写的模式来实现。
如果时效性要求不高的话，可以设置一个消息队列，专门用来接收数据库记录变更的消息，然后由专门的缓存服务去取出新数据并更新到缓存中。
2、单独过滤处理
对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截，这样避免请求穿透到后端数据库。这种方式实现起来相对复杂。

### 6. 怎么保证缓存和数据库数据的一致性
通常来说，在我们的系统中会把数据永久保存在DB中，并且冗余一份数据在缓存中。读请求优先从缓存读取数据，没有再从DB读取，读取之后然后在缓存中放置一份。在数据变更时，先淘汰缓存，再写db。（先写db，然后淘汰缓存）这样能保证基础的一致性，但是当情况变得复杂时，数据还是会出现不一致的情况。
（a）发生了写请求A，A的第一步淘汰了cache
（b）A的第二步写数据库，发出修改请求
（c）发生了读请求B，B的第一步读取cache，发现cache中是空的
（d）B的第二步读取数据库，发出读取请求，此时A的第二步写数据还没完成，读出了一个脏数据放入cache,即在数据库层面，后发出的d比先发出的b先完成了，读出了脏数据，脏数据又入了缓存，缓存与数据库中的数据不一致出现了.
这种情况的话，其实就是要将对同一片数据的操作串行起来，即做到一个服务上，且使用同一个db连接，使得在数据库上时串行的。

### 7. 持久化有几种方式？分别是什么？如何保证数据安全
RDB和AOF
RDB每次进行快照方式会重新记录整个数据集的所有信息。RDB在恢复数据时更快，可以最大化redis性能，子进程对父进程无任何性能影响。
AOF有序的记录了redis的命令操作。意外情况下数据丢失甚少。他不断地对aof文件添加操作日志记录，你可能会说，这样的文件得多么庞大呀。是的，的确会变得庞大，但redis会有优化的策略，比如你对一个key1键的操作，set key1 001 ,  set key1 002, set key1 003。那优化的结果就是将前两条去掉咯，那具体优化的配置在配置文件中对应的是
![](https://oss.wyxxt.org.cn/images/2021/09/18/d572274c43fbebe87ef28ecdc5674374.png)
前者是指超过上一次aof重写aof文件大小的百分之多少，会再次优化，如果没有重写过，则以启动时为主。后者是限制了允许重写的最小aof文件大小。bgrewriteaof命令是手动重写命令，会fork子进程，在临时文件中重建数据库状态，对原aof无任何影响，当重建旧的状态后，也会把fork发生后的一段时间内的数据一并追加到临时文件，最后替换原有aof文件，新的命令继续向新的aof文件中追加。

### 8. 怎么实现分布式锁
分布式锁一般有三种实现方式，数据库乐观锁（加版本号的），zookeeper，redis。
为什么要用分布式锁？记得之前看过关于淘宝秒杀的，直接用redis保存库存的，这种情形的话，直接在进行主业务逻辑前，对库存进行扣减，按照这种方式理论上是没问题的，但是在一些极端情况，或者这种非库存类的问题，还是存在问题的，所以这个时候就是用分布式锁，对资源进行锁定，这种可以避免数据库的传统的锁的开销，提高并发能力。

### 9. 分布式锁的缺陷
实现复杂，需要考虑超时、原子性、误删等情形。没有等待锁的队列，只能在客户端自旋来等锁、效率低下。

### 10. 如何做内存优化
一. redisObject对象 二. 缩减键值对象 三. 共享对象池 四. 字符串优化 五. 编码优化 六. 控制key的数量

### 11. 淘汰策略有哪些
noeviction：达到内存限额后返回错误，客户尝试可以导致更多内存使用的命令（大部分写命令，但DEL和一些例外）
allkeys-lru：为了给新增加的数据腾出空间，驱逐键先试图移除一部分最近使用较少的（LRC）。
volatile-lru：为了给新增加的数据腾出空间，驱逐键先试图移除一部分最近使用较少的（LRC），但只限于过期设置键。
allkeys-random: 为了给新增加的数据腾出空间，驱逐任意键
volatile-random: 为了给新增加的数据腾出空间，驱逐任意键，但只限于有过期设置的驱逐键。
volatile-ttl: 为了给新增加的数据腾出空间，驱逐键只有秘钥过期设置，并且首先尝试缩短存活时间的驱逐键

### 12. 常见性能问题有哪些？如何解决
Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
尽量避免在压力很大的主库上增加从库

### 13. 如何防止数据出错（redis事务）
redis中的事务与传统关系型数据库（如mysql）的事务是不同的。
redis中的事务是一组命令的集合，事务与命令都是最小执行单位，原理是先将属于一个事务的命令发送给Redis，然后Redis一次执行这些命令。
redis的事务可以保证一个事务内的命令一次执行而不被其他命令插入影响。
如果事务块中某一条命令出错，关系型数据库的事务会执行回滚，而redis不会执行回滚，而是会继续执行后续的命令。**因为redis的事务没有关系型数据库的回滚(rollback)功能。因此需要开发者在事务执行出错时自己处理。**
1.watch
用于监视一个或多个key，如果在事务执行(exec)之前这个或（这些）key被其他命令所改动，事务将被中断。
2.unwatch
用于取消watch命令对所有key的监视。
3.multi
用于标记一个事务块的开始，之后的所有命令都存放在队列，等遇到exec命令再执行。
4.exec
用于执行事务块内所有的命令，如果命令被中断，返回false
```php
<?php
$redis = new Redis;
$redis->connect('localhost', 6379);
// 监听
$redis->watch('mykey1','mykey2');
// 开启事务块
$redis->multi();
// 事务块语句
$redis->set('mykey1', date('Y-m-d H:i:s'));
$redis->set('mykey2', time());
// 执行事务
$result = $redis->exec();
// 取消监听
$redis->unwatch();
var_dump($result);
```
输出
```shell
array (size=2)
  0 => boolean true
  1 => boolean true
```


### 14. redis集群的搭建
[Redis集群教程](https://redis.io/topics/cluster-tutorial "Redis集群教程")
[Redis哨兵模式与高可用集群](https://juejin.im/post/5b7d226a6fb9a01a1e01ff64 "Redis哨兵模式与高可用集群")

### 15. 集群宕机，数据迁移的问题
**基础概念**
集群：是一个提供多个Redis（分布式）节点间共享数据的程序集。
集群部署：Redis 集群的键空间被分割为 16384 hash个槽（slot）， 集群的最大节点数量也是 16384 个
分片：Redis Cluster在设计中没有使用一致性哈希（Consistency Hashing），而是使用数据分片引入哈希槽（hash slot）来实现；一个 Redis Cluster包含16384（0~16383）个哈希槽，存储在Redis Cluster中的所有键都会被映射到这些slot中，集群中的每个键都属于这16384个哈希槽中的一个，集群使用公式slot=CRC16（key）/16384来计算key属于哪个槽，其中CRC16(key)语句用于计算key的CRC16 校验和。
按照槽来进行分片，通过为每个节点指派不同数量的槽，可以控制不同节点负责的数据量和请求数.
当前集群有3个节点,槽默认是平均分的:
节点 A （6381）包含 0 到 5499号哈希槽.
节点 B （6382）包含5500 到 10999 号哈希槽.
节点 C （6383）包含11000 到 16383号哈希槽.
这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中的部分槽到D上. 如果我像移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。

**数据迁移**
数据迁移可以理解为slot(槽)和key的迁移，这个功能很重要，极大地方便了集群做线性扩展，以及实现平滑的扩容或缩容。
现在要将Master A节点中编号为1、2、3的slot迁移到Master B节点中，在slot迁移的中间状态下，slot 1、2、3在Master A节点的状态表现为MIGRATING（迁移）,在Master B节点的状态表现为IMPORTING（入口）。

**宕机**
1. 集群如何判断某个节点是否挂掉
首先要说的是，每一个节点都存有这个集群所有主节点以及从节点的信息。它们之间通过互相的ping-pong判断是否节点可以连接上。如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的备用节点。

2. 集群进入fail状态的必要条件
A、某个主节点和其所有从节点全部挂掉，我们集群就进入faill状态
B、如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态
C、如果集群任意master挂掉,且当前master没有slave.集群进入fail状态

3. redis的投票机制
具体原理如下图所示：
![](https://oss.wyxxt.org.cn/images/2021/09/18/9fd3d1af3f8935a649cdfd6f1e181218.png)

    投票过程是集群中所有master参与,如果半数以上master节点与master节点通信超时(cluster-node-timeout),认为当前master节点挂掉。

    选举的依据依次是：网络连接正常->5秒内回复过INFO命令->10*down-after-milliseconds内与主连接过的->从服务器优先级->复制偏移量->运行id较小的。选出之后通过slaveif no ont将该从服务器升为新主服务器。

    通过slaveof ip port命令让其他从服务器复制该新主服务器。

    最后当旧主重新连接后将其变为新主的从服务器。***注意如果客户端与旧主服务器分隔在一起，写入的数据在恢复后由于旧主会复制新主的数据会造成数据丢失。***

4. 集群中的主从复制
集群中的每个节点都有1个至N个复制品，其中一个为主节点，其余的为从节点，如果主节点下线了，集群就会把这个主节点的一个从节点设置为新的主节点继续工作，这样集群就不会因为一个主节点的下线而无法正常工作。
注意：
1、如果某一个主节点和他所有的从节点都下线的话，redis集群就会停止工作了。redis集群不保证数据的强一致性，在特定的情况下，redis集群会丢失已经被执行过的写命令。
2、使用异步复制（asynchronous replication）是redis 集群可能会丢失写命令的其中一个原因，有时候由于网络原因，如果网络断开时间太长，redis集群就会启用新的主节点，之前发给主节点的数据就会丢失。


### 16. 怎么解决缓存雪崩与击穿？
[redis——雪崩 穿透 击穿概念详解及预防](https://wyxxt.org.cn/archives/redis-雪崩-穿透-击穿概念详解及预防.html "redis——雪崩 穿透 击穿概念详解及预防")