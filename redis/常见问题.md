# 常见问题

[存储选型](https://wyxxt.org.cn/archives/mysql-redis-hdfs-hbase-kafka存储选型.html)


[![](https://oss.wyxxt.org.cn/images/2021/09/18/5f5af5961e08531762ce9be0.png)](https://oss.wyxxt.org.cn/images/2021/09/18/5f5af5961e08531762ce9be0.png)


## redis应用场景

1. 5大value类型：string list map set sorted_set

2. 基本上就上缓存~!

3. token session 为了服务无状态，延伸思考，看你的项目有哪些数据结构或对象，在单机里需要单机锁，在多机需要分布式锁，抽出来放入redis中；
4. 无锁化

## redis 是单线程还是多线程

1. 无论什么版本，工作线程就是一个

2. 6.x高版本出现了IO对线程

3. 使用上来说，没有变化

4. 系统IO，真正理解面向IO模型编程的时候，有内核的事，从内核把数据搬运到程序里这是第一步，搬运回来的数据做的计算事第二步，netty

5. 单线程，满足redis的穿行原子，只不过IO多线程后，把输入/输出放到更多的线程去并行，好处如下：1，执行时间缩短，更快2，更好的压榨系统及硬件的资源（网卡能够高效的使用）

   *客户端读取的顺序不能被保障

   在一个连接里（socket里）顺序可以被保障

## redis 存在线程安全的问题吗？为什么？

工作线程单线程串行

redis可以保障内部串行

外界使用的时候要保障，业务上自行保障顺序～！

## 缓存穿透问题

**数据库根本没有这个数据** 

数据库通常是架构的瓶颈，要让有效请求到大数据，无效请求过滤掉

即便是放大前置环节的复杂度和成本

### 解决方案

布隆过滤器 + key null

同下

## 缓存击穿问题

**热点key过期或者没有被缓存**

redis没有，数据库有，大量并发

### 解决方案

1. 通过布隆过滤                                                                                                器

2. 请求redis无数据，抢锁

3. 抢到锁，访问数据库，更新redis

4. 抢不到锁，等待锁释放抢到锁后，再次访问redis
5. 3，4合并，抢到锁，访问redis，没有访问数据库，更新redis

## 如何避免缓存雪崩

**大量热点key同时过期**

核心问题就是避免DB无效/重复请求，涉及架构思想上的提升

### 解决方案

同上

## redis是怎么删除过期key的，缓存如何回收

1. 后台在轮询，分段分批的删除过期的key
2. 请求的时候判断时间已经过期了，删除

尽量的把内存无用空间回收回来～！

## 缓存是如何淘汰的

空间不足的情况下：

1. 淘汰机制里有不允许淘汰 **noeviction**
2. lru/lfu/random/TTL
3. 全空间,如**allkeys-lru**
4. 设置过过期的key的集合中，如**volatile-lru**

## 如何进行缓存预热

1. 提前把数据塞入redis（你知道哪些是热数据？肯定不知道，会造成线上很多数据没有缓存命中，80%预热，20%击穿，穿透，雪崩）
2. 开发逻辑上也要规避差集，会造成击穿，穿透，雪崩
3. 使用缓存击穿、穿透、雪崩一样的解决方案，一劳永逸

## 数据库和缓存不一致如何解决

1. 可以使用事务来解决，意义不大（为了解决一个问题，引入更大的一个问题，性能更低）读多写稀有的情况下
2. Canel binlog（普遍使用的方案）redis + canal + mysql 客户端写操作mysql
3. 异步化 redis + mq + mysql 客户端写操作mq
4. redis是缓存，更倾向于稍微的有时差
5. 还是减少DB的操作
6. 真的要落地，canal

## 主从不一致问题

1. redis是弱一致性，主从是异步的同步
2. 锁不能用主从的集群（单实力/分片集群/redlock）
3. 在配置中，提供了必须有多少个从连接能同步，你可以配置同步因子，趋向于强一致性
4. wait 2 5000 小心
5. 3，4点有点违背redis的初衷了

## redis持久化原理

1. 当前线程阻塞服务（不聊） AOF  立刻写 1秒写 内核写

2. 异步后台进程完成持久

   fork + copyonwrite

## redis有哪些持久化方式

1. 两个方案及2+1方案，RDB，AOF，主从同步也算持久化；
2. 高版本：开启AOF，AOF是可以通过执行日志得到全部内存数据的方式，但是追求性能：
   1. 体积变大，重复无效指令 重写，后台用线程把内存的kv生成指令写个新的AOF
   2. 4.x新增更有性能模式：把重写方式换成直接RDB放到AOF文件的头，再追加日志

## redis也扛不住了，万级流量会打到DB上，该怎么处理

尽量的去分片

解决方案见 击穿 穿透 缓存雪崩

## redis中的三条指令式是什么，第三条指令到达后执行失败了，怎么处理

事务没有回滚～！

少使用事务，事务内的指令尽量的少和快

## redis实现分布式锁的指令

## 为什么使用setnx

1. 好东西，原子性操作（不存在的情况下完成创建）
2. 如果要做分布式锁，就要用set k v nx ex(不存在，过期时间)

