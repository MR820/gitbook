## dos时代

同一时间只能有一个进程在运行


- 弊端：
  cpu 内存 硬盘的速度差异过大，cpu大部分时间处于等待状态，效率极低

## 多进程


多个进程全部装入内存


- 弊端：
  1、内存撑爆
  2、互相打扰，不小心访问到别人的空间

## 现代内存管理系统


虚拟地址
分页装入
软硬件结合寻址

![](https://oss.wyxxt.org.cn/images/2021/09/18/wp_editor_md_bf57c4d6fe17e18b101a9f6b6cafabc1.jpg)

### 1、分页

**解决内存撑爆问题**

分块装入页框中（内存页 4k标准页）

为什么可以分块装入叶框中

- 局部性原理：
  时间局部性-指令旁边的指令很快执行
  空间局部性-数据旁边的数据很快用到

内存满了，进行交换分区（LRU算法）

### 2、虚拟内存

**解决相互打扰问题**

dos win31互相干掉

为了保证互不影响，让进程工作在虚拟空间（每个进程都有自己的虚拟空间），程序中用到的空间地址不再是直接的物理地址，而是虚拟的地址，这样A进程永远不可能访问到B进程的空间

虚拟空间多大了？寻址空间-64位系统 2^64 bit
站在虚拟的角度，进程是独享整个系统+cpu


![](https://oss.wyxxt.org.cn/images/2021/09/18/wp_editor_md_d971590bac367c02d628a8a153318e44.jpg)

## 分段

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。**

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。



![image-20231225183657076](https://oss.wyxxt.org.cn/images/2023/12/25/8064356a-80ac-495b-9269-936ccfb832b8.png)

分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

### 弊端

1. 内存碎片问题

2. 内存交换的效率低

   ![image-20231225184323071](https://oss.wyxxt.org.cn/images/2023/12/25/83988341-9610-4491-bc6b-7dd8eb5d477e.png)

内存碎片主要分为，内部内存碎片和外部内存碎片。

内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大的段，所以**不会出现内部内存碎片**。

但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以**会出现外部内存碎片**的问题。

解决「外部内存碎片」的问题就是**内存交换**。

可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。

这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。

对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 `Swap` 内存区域，这个过程会产生性能瓶颈。

因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。

所以，**如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。**

## 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

![image-20231225184544928](https://oss.wyxxt.org.cn/images/2023/12/25/7003082b-da0b-4d94-808f-aac8fa34ed95.png)