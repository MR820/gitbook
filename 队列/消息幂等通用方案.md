消息中间件是分布式系统常用的组件，无论是异步化、解耦、削峰等都有广泛的应用价值。

队列保证了消息不丢，不重需要应用程序自我实现。

## 简单的消息去重方案

```go
select * form d_order where order_no = "no012";
if order_no != nil {
	return false // 消息重复，直接返回
}
insert ...
```

并发场景下会有问题

## 并发重复消息

如果在插入前，有并发过来，会穿透挡板

## 并发去重的解决方案

开启事务，select for update把记录锁定

```go
select * form d_order where order_no = "no012" for update;
if order_no != nil {
	return false // 消息重复，直接返回
}
insert ...
```

因为引入了事务包裹而导致整个消息消费可能变长，并发度下降

乐观锁，基于业务表本身做去重，这无疑增加了业务开发的复杂度

## exactly once

消息被处理，且仅处理一次

## 基于关系数据库插入消息表

```sql
update d_order set status = 'SUCCESS' where order_no = "no012";
```

1. 开启事务
2. 插入消息表（处理好主键冲突的问题）
3. 更新订单表（原消费逻辑）
4. 提交事务

这时候如果消息消费成功并且事务提交了，那么消息表就插入成功了，这时候就算队列还没有收到消费位点的更新再次投递，也会插入消息失败而视为已经消费过，后续就直接更新消费位点了。这保证我们消费代码只会执行一次

如果事务提交之前服务挂了（例如重启），对于本地事务并没有执行所以订单没有更新，消息表也没插入成功；而对于队列来说，消费位点也没更新，所以消息还会继续投递下来，投递下来发现这个消息插入消息表也是成功的，所以可以继续消费。这保证了消息不丢失。

这种方案跟业务本身无关，而是依赖消息表。但是基于事务，可能导致锁表时间过长等性能问题

局限性：

以来关系型数据库，如何还涉及到其他数据源的修改，则不可用

数据库的数据必须在一个库，不可跨库

## 更复杂的业务场景

1. 检查库存（RPC）
2. 锁库存（RPC）
3. 开启事务，插入订单表（MySQL）
4. 调用某些其他下游服务（RPC）
5. 更新订单状态
6. commit 事务（MySQL）

这种情况下，我们如果采取消息表+本地事务的实现方式，消息消费过程中很多子过程是不支持回滚的，也就是说就算我们加了事务，实际上这背后的操作并不是原子性的。

服务重启了，这时候实际上库存是已经在另外的服务里被锁定了，这并不能被回滚。当然消息还会再次投递下来，要保证消息能至少消费一遍。锁库存的这个RPC接口本身依旧要支持“幂等”。

在这个比较耗时的长链条场景下加入事务的包裹，将大大的降低系统的并发。所以通常情况下，我们处理这种场景的消息去重的方法还是会使用一开始说的业务自己实现去重逻辑的方式，如前面加select for update，或者使用乐观锁。

## 拆解消息执行过程

![image-20231220165759874](https://oss.wyxxt.org.cn/images/2023/12/20/36ebae15-f030-43e1-8364-340f9f03e69e.png)

这样的处理方法会使得每一步的操作都比较原子，而原子则意味着是小事务，小事务则意味着使用消息表+事务的方案显得可行。

## 更通用的解决方案

上面消息表+本地事务的方案之所以有其局限性和并发的短板，究其根本是因为它**依赖于关系型数据库的事务**，且必须要把事务包裹于整个消息消费的环节。

如果我们能不依赖事务而实现消息的去重，那么方案就能推广到更复杂的场景例如：RPC、跨库等。

我们依旧使用消息表，但是不依赖事务，而是针对消息表增加消费状态

## 基于消息幂等表的非事务方案

![image-20231220170727973](https://oss.wyxxt.org.cn/images/2023/12/20/01f6ecd7-0090-44fb-9a48-08c72ca37f98.png)

1. 消息已经消费成功了，第二条消息将被直接幂等处理掉（消费成功）。
2. 并发场景下的消息，依旧能满足不会出现消息重复，即穿透幂等挡板的问题。
3. 支持上游业务生产者重发的业务重复的消息幂等问题。



问题

消息一直在消费中，但前一个消费服务重启或异常，已经丢失

![image-20231220174244892](https://oss.wyxxt.org.cn/images/2023/12/20/998bb86c-09a8-4d14-9ea5-7216fde212ba.png)

## 消息表存储媒介

此没有事务的，只需要一个存储的中心媒介，那么自然我们可以选择更灵活的存储媒介，例如Redis。使用Redis有两个好处：

1. 性能上损耗更低
2. 超时时间可以直接利用Redis本身的ttl实现